---
title: "Exploring the Magic of Randomization"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    theme:
      version: 4
      bg: "#FFFFFF"
      fg: "#3F433D"
      primary: "#00727C"
      navbar-bg: "#221F20"
      base_font: 
        google: Lato
runtime: shiny
---

<style>label {font-size: 0.8em}</style>

```{r setup, include=FALSE}
library(flexdashboard)
library(shinyWidgets)  # Tweak some of the controls
library(tidyverse)
library(gt)            # Nicer table
library(htmltools)     # Nicer table formatting
library(scales)        # Formatting some percentages
library(randomcoloR)
library(randomizr)    # So we can do complete random assignment easily
library(patchwork)     # Arrange some plots side by side

set.seed(61705)

theme_main <- theme_void() +
  theme(plot.title.position = "plot",
        plot.title = element_text(hjust = 0.5, family = "Lato", color = "#7A7574", face = "bold"))

```

Inputs {.sidebar}
-----------------------------------------------------------------------

<div style = "font-size: 0.9em; font-style: italic; margin: 10px 0px 10px 0px;">Configure the base data set parameters and then click the button to build it. and the number of colors and then click the button to run a simulation.</div>

```{r base_data}
# Basically, set a value that will be the number of rows and 1/2 of the # of columns
sliderTextInput("data_size", label = "Size of the Data Set:", 
                grid = FALSE, force_edges = TRUE,
                choices = c("Small", seq(6:39) %>% as.character, "Large"),
                selected = "20"
)

sliderInput("num_colors", label = "Number of Unique Colors:",
            min = 3, max = 8, value = 6, step = 1)

# Set the effect size. Be omnipotent!
sliderTextInput("effect_size", label = "Treatment Effect*:", 
                grid = FALSE, force_edges = TRUE,
                choices = c("0%", "1%", "5%", "10%", "15%", "20%", "25%", "30%"),
                selected = "15%"
)

# Set how predictive "color" is of the outcome
sliderTextInput("color_predictiveness", label = "Outcome Predictiveness of Color:", 
                grid = FALSE, force_edges = TRUE,
                choices = c("None", "Weakly Predictive", "Strongly Predictive"),
                selected = "Weakly Predictive"
)
```

<div style = "text-align: center;">
```{r build_data_button}
# This is to build the base, all-knowing data frame. Simulations will then
# split this data set into treatment and control and try it out.
actionButton("build_data", "1. Build Data Set")
```
</div>

<div style="font-size: 0.7em; font-style: italic;">\* You're omnipotent! (You wouldn't know this in reality.)</div>

<hr>

Choose design options and run the simulation:

```{r design options}
materialSwitch(inputId = "blocking", label = "Block on Color", value = FALSE,
               status = "success", right = FALSE)
```

<div style = "text-align: center;">
```{r addl_settings}
actionButton("run_simulation", "2. Run Simulation")
```
</div>

```{r build_data}

# Get the data size. This translates what is a text input into a numeric
get_data_size <- eventReactive(input$build_data,
                               {
                                 data_size <- case_when(
                                   input$data_size == "Small" ~ 5,
                                   input$data_size == "Large" ~ 40,
                                   TRUE ~ as.numeric(input$data_size)
                                 )
                               })

# Get the num_rows and num_cols
get_num_rows <- reactive({get_data_size()})
get_num_cols <- reactive({get_data_size() * 2})

# Calculate the total observations
get_total_obs <- reactive({get_num_rows() * get_num_cols()})

# Create a data frame with random colors and potential outcomes. This is one
# observation per row, but we'll ultimately  plot on a grid, just for 
# compactness's sake
get_data <- eventReactive(input$build_data, {
  
  # Get a data frame with the colors. This has the unique number of colors
  # based on user input, but then those colors are repeated at varying 
  # frequencies so that they are not all just evenly distributed
  colors_df <- tibble(colors = randomColor(input$num_colors,
                                           hue = "random",
                                           luminosity = "bright"),
                      weight = sample(1:10, input$num_colors, replace = TRUE))
  
  expand_colors <- function(color, rep_ct){
    tibble(color = rep(color, rep_ct))
  }
  colors_exp_df <- map2_dfr(colors_df$colors, colors_df$weight, expand_colors)
  
  # Get the total observations (count)
  total_obs <- get_total_obs()
  
  # Build the main data frame
  df <- tibble(idx = seq(1:total_obs),
               color_row = sample(1:nrow(colors_exp_df), 
                                  total_obs, replace = TRUE)) %>% 
    # Set a color
    mutate(color = colors_exp_df$color[color_row]) %>% 
    # Split out the R, G, and B values
    mutate(red = substr(color, 2, 3) %>% strtoi(base = 16),
           green = substr(color, 4, 5) %>% strtoi(base = 16),
           blue = substr(color, 6, 7) %>% strtoi(base = 16))
  # Set x and y values
  df$x_pos <- rep(1:get_num_cols(), length.out = nrow(df))
  df$y_pos <- rep(1:get_num_rows(), each=get_num_cols())
  
  # Set the potential outcomes. Y_0 is the potential outcome with no treatment
  # and Y_1 is the potential outcome with treatment. These will be set up
  # in the initial data set based on the selected effect size and the predictive
  # level of color.
  
  # The "base" for Y_0 is simply 1,000 (this could be an input, too...but why?)
  base_Y0 <- 1000
  
  # Turn the selected effect size into something that can be multiplied by
  # the base to set the base for the treatment
  effect_scale <- gsub("%", "", input$effect_size) %>% as.numeric()/100 + 1
  base_Y1 <- base_Y0 * effect_scale
  
  # Set a multiplier that will vary the levels by color. This will randomly assign
  # a multiplier for each color, and then that multiplier will be applied to both
  # base_Y0 and base_Y1
  color_multipliers <- df %>% 
    group_by(color) %>% summarise() %>% ungroup()
  
  color_multipliers$color_multiplier <- case_when(
    input$color_predictiveness == "Strongly Predictive" ~ 
      1 + sample(0:3, nrow(color_multipliers), replace = TRUE) * 8/10,
    input$color_predictiveness == "Weakly Predictive" ~ 
      1 + sample(0:5, nrow(color_multipliers), replace = TRUE)/10,
    TRUE ~ 1)
  
  # Add the multiplier in as a scaling factor to the base data
  df <- df %>%
    left_join(color_multipliers)
  
  # Hardcoding the variability within the data. This may need some tinkering.
  # But this is generating the no-treatment vs. treatment values
  df$Y0 <- runif(nrow(df), base_Y0 * 0.85, base_Y0 * 1.15)
  df$Y1 <- runif(nrow(df), base_Y1 * 0.85, base_Y1 * 1.15)
  
  # Now scale by the "color factor."
  df <- df %>% 
    mutate(Y0 = Y0 * color_multiplier,
           Y1 = Y1 * color_multiplier)
})

get_assignments <- eventReactive(input$run_simulation, {
  
  # Get the master data set
  df <- get_data()
  total_obs <- nrow(df)
  
  # Assign treatment (1) and control (0)
  if(input$blocking == TRUE){
    df$assignment <- block_ra(df$color, prob = 0.5)
  } else {
    df$assignment <- complete_ra(total_obs, prob = 0.5)
  }
  
  # Populate the colors for the treatment and control groups
  df <- df %>% 
    mutate(color_control = if_else(assignment == 0, color, "gray90"),
           color_treatment = if_else(assignment == 1, color, "gray90"))
  
  df
})

# Get a data frame for just the treatment observations
get_treatment <- reactive({
  df <- get_assignments() %>% filter(assignment == 1) 
  # Set x and y values
  df$x_pos <- rep(1:(get_num_cols()/2), length.out = nrow(df))
  # Might not be a perfect split, so go a little long and then clip it
  df$y_pos <- rep(1:(get_num_rows()+2), each=get_num_cols()/2)[1:nrow(df)]
  df
})

# Get a data frame for just the control observations
get_control <- reactive({
  df <- get_assignments() %>% filter(assignment == 0) 
  # Set x and y values
  df$x_pos <- rep(1:(get_num_cols()/2), length.out = nrow(df))
  # Might not be a perfect split, so go a little long and then clip it
  df$y_pos <- rep(1:(get_num_rows()+2), each=get_num_cols()/2)[1:nrow(df)]
  df
})
```

Row {data-height=100}
-----------------------------------------------------------------------

### The Colors Represent a Heterogeneous Aspect of Our Sample

That's just a fancy way of saying, "It varies." Think of this as being something like household income or race or age group. In an RCT, there is all sorts of "unobserved heterogeneity": underlying aspects of the experimental groups that we may not be measurable.

Row {data-height=1250 .tabset}
-----------------------------------------------------------------------

### Overall Dataset

####

```{r overall_dataset}

# Plot a grid of the colors
output$plot_all <- renderPlot({
  
  total_obs <- get_total_obs()
  df_master <- get_data()
  
  ggplot(df_master, aes(x = x_pos, y = y_pos, fill = color)) + 
    geom_tile(color = "white", size = 1) +
    labs(title = paste(format(total_obs, big.mark = ","), "Observations")) +
    scale_fill_identity() +
    theme_main
},
height = 400, width = 800)

plotOutput("plot_all")

# Show the underlying data table
output$data_master <- render_gt({
  df_master <- get_data() 
  
  # Function to take the hex values for a color and return it as a gt HTML value.
  # This can't be done right in the the mutate call, so setting as a function that
  # returns the HTML-ified value.
  add_cell_color <- function(col) {
    
    cell_color = paste0("display: inline-block; padding: 2px 12px; ",
                        "border-radius: 15px; font-weight: 600; font-size: 12px; ",
                        "background: ", col, "; color: white;") %>% 
      htmltools::div(style = ., col) %>% as.character() %>% gt::html()
  }
  
  df_master <- df_master %>% 
    head(20) %>% 
    mutate(effect = percent((Y1 - Y0)/Y0, accuracy = 0.1),
           Y0 = round(Y0, 0) %>% format(big.mark = ","),
           Y1 = round(Y1, 0) %>% format(big.mark = ",")) %>% 
    # Add a text string with the HTML to color the cells
    mutate(color = purrr::map(color, add_cell_color)) %>% 
    select(idx, color, Y0, Y1, effect) 
  
  names(df_master) <- c("Index","Color", "Y0", "Y1", "Effect")
  
  df_master %>% gt(rowname_col = "Index") %>% 
    tab_header(
      title = "A Glimpse of the Data",
      subtitle = html("The table below reflects the first few observations from the underlying data set (starting from the bottom left). The Y<sub>0</sub> and Y<sub>1</sub> are potential outcomes: we're operating in a world where we know exactly what outcome we would see whether each observation received or did not receive treatment. These are affected by the Treatment Effect and the Outcome Predictiveness of Color selected at left.")) %>% 
    tab_spanner(
      label = "Potential Outcomes",
      columns = c(Y0, Y1)
    ) %>% 
    cols_label(Y0 = gt::html("Y<sub>0</sub> (Not Treated)"), 
               Y1 = gt::html("Y<sub>1</sub> (Treated)")) %>% 
    tab_options(data_row.padding = px(2)) %>%
    cols_width(Index ~ px(40),
               Color ~ px(100),
               starts_with("Y") ~px(150),
               Effect ~ px(100)) %>%
    cols_align(align = "right",
               columns = everything()) %>% 
    cols_align(align = "center",
               columns = c(Index, Color))
})

gt_output("data_master")

```

### Treatment vs. Control

We've performed _random assignment_ to split the data into two groups: a control group and a treatment group.

```{r}
# Plot the control and treatment in the same grid maintaining the same layout as the
# master view of the observations
output$plot_split <- renderPlot({
  df_master <- get_assignments()
  gg_control <- ggplot(df_master, aes(x = x_pos, y = y_pos, fill = color_control)) + 
    geom_tile(color = "white", size = 1) +
    labs(title = "Control Group") +
    scale_fill_identity() +
    theme_main
  
  gg_treatment <- ggplot(df_master, aes(x = x_pos, y = y_pos, fill = color_treatment)) + 
    geom_tile(color = "white", size = 1) +
    labs(title = "Treatment Group") +
    scale_fill_identity() +
    theme_main
  
  gg_control / gg_treatment
},
height = 800, width = 800)

plotOutput("plot_split")
```

### Color Comparison

We can take our two groups and calculate the "average" color for each group. Pretty close, right?! Is the distribution of the colors across these two groups _identical_? No! But, are they _similar_? Yes! Randomization!!! There are countless characteristics in an RCT that differ across subjects that may or may not be observable. Randomization helps ensure that these differences "come out in the wash." 

```{r}

output$plot_comparison <- renderPlot({
  
  df_control <- get_control()
  df_treatment <- get_treatment()
  
  ############
  # Make tiled plots. We'll then put them next to each other i na bit.
  ############
  
  gg_treatment <- ggplot(df_treatment, aes(x = x_pos, y = y_pos, fill = color)) + 
    geom_tile(color = "white", size = 1) +
    labs(title = "Treatment Group") +
    scale_fill_identity() +
    theme_main
  
  gg_control <- ggplot(df_control, aes(x = x_pos, y = y_pos, fill = color)) + 
    geom_tile(color = "white", size = 1) +
    labs(title = "Control Group") +
    scale_fill_identity() +
    theme_main
  
  ############
  # Plot the "Mean Color" for each
  ############
  
  # Calculate the mean color for treatment and control and then make a plot
  # that shows them. The is sneaky: the plots plots...nothing. But, they then
  # then makes the background color the mean color in the theme
  mean_control <- rgb(mean(df_control$red),
                      mean(df_control$green),
                      mean(df_control$blue),
                      maxColorValue = 255)
  
  gg_control_mean <- ggplot() +
    labs(title = paste("Mean Control Color:", mean_control)) +
    theme_main +
    theme(plot.title = element_text(margin = margin(0.25,0,0.25,0, "cm")),
          panel.background = element_rect(fill = mean_control, color = NA),
          panel.border = element_rect(fill = NA, colour = "white", size = 10))
  
  mean_treatment <- rgb(mean(df_treatment$red),
                        mean(df_treatment$green),
                        mean(df_treatment$blue),
                        maxColorValue = 255)
  
  gg_treatment_mean <- ggplot() +
    labs(title = paste("Mean Treatment Color:", mean_treatment)) +
    theme_main +
    theme(plot.title = element_text(margin = margin(0.25,0,0.25,0, "cm")),
          panel.background = element_rect(fill = mean_treatment, color = NA),
          panel.border = element_rect(fill = NA, colour = "white", size = 10))
  
  ############
  # Make bar charts showing the color breakout
  ############
  
  # Get the max value so common limits can be set for the bar charts
  max_val <- get_assignments() %>% 
    group_by(color, assignment) %>% summarise(obs = n()) %>% 
    pull(obs) %>% max()
  
  # Get the colors by total occurrences to use for factors / ordering
  color_levels <- get_assignments() %>% 
    group_by(color) %>% summarise(obs = n()) %>% 
    arrange(obs) %>% pull(color)
  
  # Control
  df_control_summary <- df_control %>% 
    group_by(color) %>% summarise(obs = n()) %>% arrange(obs) 
  df_control_summary$color <- factor(df_control_summary$color, levels = color_levels)
  
  gg_control_bar <- ggplot(df_control_summary, aes(x = color, y = obs, fill = color, 
                                                   label = format(obs, big.mark = ",", trim = TRUE))) +
    geom_bar(stat = "identity") +
    geom_text(hjust = 0, nudge_y = max_val/50, family = "Lato") +
    scale_y_continuous(limits = c(0, max_val * 1.1)) +
    scale_fill_identity() +
    coord_flip() +
    labs(title = "Control: Color Breakdown") +
    theme_void() +
    theme(plot.title.position = "plot",
          plot.title = element_text(hjust = 0.5, family = "Lato", color = "#7A7574", 
                                    face = "bold", margin = margin(0.25,0,0.25,0, "cm")),
          legend.position = "none")
  
  # Treatment
  df_treatment_summary <- df_treatment %>% 
    group_by(color) %>% summarise(obs = n()) %>% arrange(obs) 
  df_treatment_summary$color <- factor(df_treatment_summary$color, levels = color_levels)
  
  gg_treatment_bar <- ggplot(df_treatment_summary, aes(x = color, y = obs, fill = color, 
                                                       label = format(obs, big.mark = ",", trim = TRUE))) +
    geom_bar(stat = "identity") +
    geom_text(hjust = 0, nudge_y = max_val/50, family = "Lato") +
    scale_y_continuous(limits = c(0, max_val * 1.1)) +
    scale_fill_identity() +
    coord_flip() +
    labs(title = "Treatment: Color Breakdown") +
    theme_void() +
    theme(plot.title.position = "plot",
          plot.title = element_text(hjust = 0.5, family = "Lato", color = "#7A7574", 
                                    face = "bold", margin = margin(0.25,0,0.25,0, "cm")),
          legend.position = "none")
  
  # Output
  (gg_control | gg_treatment) / 
    (gg_control_mean | gg_treatment_mean) / 
    (gg_control_bar | gg_treatment_bar) +
    plot_layout(heights = c(3, 1, 2))
  
  
}, height = 800, width = 800)

plotOutput("plot_comparison")

```

### Treatment Effect

#### True Effect

```{r get_true}

output$true_effect <- renderText({
  df <- get_data()
  effect <- (sum(df$Y1) - sum(df$Y0)) / sum(df$Y0) 
  msg <- paste("The (unknowable) true effect is", effect %>% percent(accuracy = 0.1))
})

textOutput("true_effect")

```

#### Observed Effect

```{r get_observed}

output$observed_effect <- renderText({
  df_control <- get_control()
  df_treatment <- get_treatment()
  effect <- (sum(df_treatment$Y1) - sum(df_control$Y0)) / sum(df_control$Y0) 
  msg <- paste("The observed effect is", effect %>% percent(accuracy = 0.1))
})

textOutput("observed_effect")

```

### Multi-Run Simulation

_In reality, we only run one experiment. But, with simulation, we can run the same experiment (re-doing the random assignment of treatment and control each time) 1,000 times._

<div style = "text-align: center;">
```{r multi_sim_action}
actionButton("run_many_sims", "Run 1,000 Simulations")
```


```{r get_simulation}

get_simulation <- eventReactive(input$run_many_sims, {
  
  # Get the master data set
  df <- get_data()
  total_obs <- nrow(df)
  
  # Create a data frame with 1,000 rows for the simulation
  sim_df <- tibble(index = seq(1:1000))
  
  # Function to split into treatment and control and then get an observed effect.
  # This will get run multiple times so that a sampling distribution can be constructed.
  get_observed_effect <- function(idx){
    
    # Assign treatment (1) and control (0)
    if(input$blocking == TRUE){
      df$assignment <- block_ra(df$color, prob = 0.5)
    } else {
      df$assignment <- complete_ra(total_obs, prob = 0.5)
    }
    
    # Summarize
    df <- df %>% 
      group_by(assignment) %>% 
      summarize(Y0 = sum(Y0),
                Y1 = sum(Y1))
    
    obs_Y0 <- df %>% filter(assignment == 0) %>% pull(Y0)
    obs_Y1 <- df %>% filter(assignment == 1) %>% pull(Y1)
    
    obs_effect <- (obs_Y1 - obs_Y0) / obs_Y0
    
    df <- tibble(index = idx, obs_effect = obs_effect)
    
  }
  
  sim_df <- map_dfr(sim_df$index, get_observed_effect)
})

# Build the plot of the simulation
output$sampling_dist <- renderPlot({
  simulation_df <- get_simulation()
  mean_obs <- mean(simulation_df$obs_effect)
  sd_obs <- sd(simulation_df$obs_effect)
  
  ggplot() + 
    geom_histogram(data = simulation_df, mapping = aes(obs_effect), fill = "#009CAB", alpha = 0.5, bins = 10) +
    # Plot the Mean
    geom_vline(aes(xintercept = mean_obs)) +
    geom_text(data = tibble(x = mean_obs, y = 80, label = paste("Mean:", percent(mean_obs, accuracy = 0.1))),
              mapping = aes(x = x, y = y, label = label),
              hjust = 0, nudge_x = 0.0015) +
    # Plot + 2SD
    geom_vline(aes(xintercept = mean_obs + 2 * sd_obs), linetype = "dashed") +
    geom_text(data = tibble(x = mean_obs + 2 * sd_obs, y = 80, label = paste("+2 SD:", percent(mean_obs + 2 * sd_obs, accuracy = 0.1))),
              mapping = aes(x = x, y = y, label = label),
              hjust = 0, nudge_x = 0.0015) +
    # Plot - 2SD
    geom_vline(aes(xintercept = mean_obs - 2 * sd_obs), linetype = "dashed") +
    geom_text(data = tibble(x = mean_obs - 2 * sd_obs, y = 80, label = paste("-2 SD:", percent(mean_obs - 2 * sd_obs, accuracy = 0.1))),
              mapping = aes(x = x, y = y, label = label),
              hjust = 1, nudge_x = -0.0015) +
    labs(title = "Sampling Distribution of the Observed Effect",
         subtitle = "1,000 Simulations of the Experiment",
         x = "Observed Effect") +
    scale_y_continuous(expand = c(0,0)) +
    scale_x_continuous(labels = percent) +
    theme_void() +
    theme(plot.title.position = "plot",
          plot.title = element_text(face = "bold"),
          axis.text.x = element_text(margin = margin(8, 0, 8, 0, "pt")),
          axis.title.x = element_text(face = "bold"),
          axis.line.x = element_line(color = "#3F433D"))
},
height = 400, width = 800)

plotOutput("sampling_dist")

```

</div>